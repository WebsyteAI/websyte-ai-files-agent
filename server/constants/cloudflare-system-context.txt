TITLE: Creating an AI Chat Agent using `AIChatAgent` and OpenAI in TypeScript
DESCRIPTION: Example of a `DialogueAgent` extending `AIChatAgent` from `agents/ai-chat-agent` to facilitate conversational AI. It overrides `onChatMessage`, using utilities like `createDataStreamResponse` and `streamText` from `@ai-sdk/openai` to stream responses from an OpenAI model (gpt-4o) based on the current message history (`this.messages`). The `onFinish` callback, passed to `streamText`, ensures messages are saved by the base `AIChatAgent` after the stream completes.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_12

LANGUAGE: typescript
CODE:
```
import { AIChatAgent } from "agents/ai-chat-agent";
import { openai } from "@ai-sdk/openai";
import { createDataStreamResponse, streamText } from "@ai-sdk/core"; // Assumed import for createDataStreamResponse

export class DialogueAgent extends AIChatAgent {
  async onChatMessage(onFinish) {
    return createDataStreamResponse({
      execute: async (dataStream) => {
        const stream = streamText({
          model: openai("gpt-4o"),
          messages: this.messages,
          onFinish, // call onFinish so that messages get saved
        });

        stream.mergeIntoDataStream(dataStream);
      },
    });
  }
}
```

----------------------------------------

TITLE: Handling WebSocket Connections in an Agent using TypeScript
DESCRIPTION: Shows a `DialogueAgent` extending `Agent` designed to handle persistent WebSocket connections. It implements the `onConnect` method, likely for initializing the connection state, and the `onMessage` method to process incoming messages, perform comprehension, and send responses back through the connection.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_6

LANGUAGE: typescript
CODE:
```
export class DialogueAgent extends Agent {
  async onConnect(connection) {
    await this.initiate(connection);
  }

  async onMessage(connection, message) {
    const understanding = await this.comprehend(message);
    await this.respond(connection, understanding);
  }
}
```

----------------------------------------

TITLE: Handling HTTP Requests within an Agent in TypeScript
DESCRIPTION: Defines an `APIAgent` class that extends `Agent` from the `agents` package. It overrides the `onRequest` method to specifically handle incoming HTTP requests. The method parses the request body as JSON, processes the data using a hypothetical `this.process` method, and returns a JSON response containing the result and a timestamp.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_5

LANGUAGE: typescript
CODE:
```
export class APIAgent extends Agent {
  async onRequest(request) {
    const data = await request.json();

    return Response.json({
      insight: await this.process(data),
      moment: Date.now(),
    });
  }
}
```

----------------------------------------

TITLE: Building a React Chat Interface with `useAgentChat`
DESCRIPTION: Demonstrates creating a React chat UI using hooks from the `agents` framework. It first connects to the agent using `useAgent`. Then, `useAgentChat` (from `agents/ai-react`) manages the chat state, providing `messages`, `input` value, `handleInputChange`, `handleSubmit` for sending messages, and `clearHistory`. The component renders the message history and an input form, enabling real-time, interactive chat with the connected AI agent.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_13

LANGUAGE: tsx
CODE:
```
import { useAgent } from "agents/react";
import { useAgentChat } from "agents/ai-react";

function ChatInterface() {
  // Connect to the agent
  const agent = useAgent({
    agent: "dialogue-agent",
  });

  // Set up the chat interaction
  const { messages, input, handleInputChange, handleSubmit, clearHistory } =
    useAgentChat({
      agent,
      maxSteps: 5,
    });

  return (
    <div className="chat-interface">
      {/* Message History */}
      <div className="message-flow">
        {messages.map((message) => (
          <div key={message.id} className="message">
            <div className="role">{message.role}</div>
            <div className="content">{message.content}</div>
          </div>
        ))}
      </div>

      {/* Input Area */}
      <form onSubmit={handleSubmit} className="input-area">
        <input
          value={input}
          onChange={handleInputChange}
          placeholder="Type your message..."
          className="message-input"
        />
      </form>

      <button onClick={clearHistory} className="clear-button">
        Clear Chat
      </button>
    </div>
  );
}
```

----------------------------------------

TITLE: Implementing HumanInTheLoop Agent Class in TypeScript
DESCRIPTION: Defines an AI chat agent class that processes messages and checks for tool calls requiring human confirmation before execution. It implements the onChatMessage method to handle message processing and response streaming.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/human-in-the-loop/README.md#_snippet_0

LANGUAGE: typescript
CODE:
```
export class HumanInTheLoop extends AIChatAgent<Env> {
  async onChatMessage(onFinish: StreamTextOnFinishCallback<any>) {
    return createDataStreamResponse({
      execute: async (dataStream) => {
        // Process messages and check for tool calls requiring confirmation
        const processedMessages = await processToolCalls({
          messages: this.messages,
          dataStream,
          tools: {
            getWeatherInformation: {
              requiresApproval: true,
              execute: async ({ city }) => {
                // Example tool implementation
                return `The weather in ${city} is sunny.`;
              },
            },
          },
        });

        // Stream response using the processed messages
        streamText({
          model: openai("gpt-4o"),
          messages: processedMessages,
          tools,
          onFinish,
        }).mergeIntoDataStream(dataStream);
      },
    });
  }
}
```

----------------------------------------

TITLE: Defining a Basic Agent Class in TypeScript
DESCRIPTION: Shows the fundamental structure of an agent by extending the `Agent` class from the `agents` package. It implements the asynchronous `onRequest` method to handle incoming requests and return a simple `Response` object. This serves as the starting point for creating custom agent logic.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { Agent } from "agents";

export class IntelligentAgent extends Agent {
  async onRequest(request) {
    // Transform intention into response
    return new Response("Ready to assist.");
  }
}
```

----------------------------------------

TITLE: Managing Agent State with `setState` and `onStateUpdate` in TypeScript
DESCRIPTION: Shows how an agent (`ThinkingAgent` extending `Agent`) can manage its internal, persistent state. The `evolve` method demonstrates updating the state using `this.setState`, merging new insights into an array and incrementing an understanding counter. The `onStateUpdate` lifecycle hook is called automatically whenever the state changes, allowing the agent to react to its own state updates.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_9

LANGUAGE: typescript
CODE:
```
export class ThinkingAgent extends Agent {
  async evolve(newInsight) {
    this.setState({
      ...this.state,
      insights: [...(this.state.insights || []), newInsight],
      understanding: this.state.understanding + 1,
    });
  }

  onStateUpdate(state, source) {
    console.log("Understanding deepened:", {
      newState: state,
      origin: source,
    });
  }
}
```

----------------------------------------

TITLE: Integrating OpenAI with an Agent in TypeScript
DESCRIPTION: Demonstrates creating an `AIAgent` that utilizes the OpenAI API for chat completions. It requires the `agents` and `openai` packages. Inside `onRequest`, it initializes the OpenAI client using an API key from environment variables (`this.env.OPENAI_API_KEY`), sends the request text to the specified model ('gpt-4'), and returns the AI's response content. An example `processTask` method outline is also included.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_2

LANGUAGE: typescript
CODE:
```
import { Agent } from "agents";
import { OpenAI } from "openai";

export class AIAgent extends Agent {
  async onRequest(request) {
    // Connect with AI capabilities
    const ai = new OpenAI({
      apiKey: this.env.OPENAI_API_KEY,
    });

    // Process and understand
    const response = await ai.chat.completions.create({
      model: "gpt-4",
      messages: [{ role: "user", content: await request.text() }],
    });

    return new Response(response.choices[0].message.content);
  }

  async processTask(task) {
    await this.understand(task);
    await this.act();
    await this.reflect();
  }
}
```

----------------------------------------

TITLE: Implementing Hono Agent Classes and Middleware
DESCRIPTION: This TypeScript snippet shows how to define agent classes, instantiate a Hono application, and integrate the agents middleware. It sets up the agent classes which extend from "Agent" class, including methods like onRequest, for handling requests. It then integrates agentsMiddleware into the Hono application for routing and handling incoming requests to the AI agents.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/hono-agents/README.md#_snippet_1

LANGUAGE: typescript
CODE:
```
import { Hono } from "hono";
import { Agent } from "agents";
import { agentsMiddleware } from "hono-agents";

// Define your agent classes
export class ChatAgent extends Agent {
  async onRequest(request) {
    return new Response("Ready to assist with chat.");
  }
}

export class AssistantAgent extends Agent {
  async onRequest(request) {
    return new Response("I'm your AI assistant.");
  }
}

// Basic setup
const app = new Hono();
app.use("*", agentsMiddleware());

// or with authentication
app.use(
  "*",
  agentsMiddleware({
    options: {
      onBeforeConnect: async (req) => {
        const token = req.headers.get("authorization");
        // validate token
        if (!token) return new Response("Unauthorized", { status: 401 });
      },
    },
  })
);

// With error handling
app.use("*", agentsMiddleware({ onError: (error) => console.error(error) }));

// With custom routing
app.use(
  "*",
  agentsMiddleware({
    options: {
      prefix: "agents", // Handles /agents/* routes only
    },
  })
);

export default app;
```

----------------------------------------

TITLE: Synchronizing Agent State with React UI using `useAgent`
DESCRIPTION: Demonstrates synchronizing an agent's state with a React component's local state. The `useAgent` hook connects to `thinking-agent` and uses the `onStateUpdate` callback to update the local React state (`setState`) whenever the agent's state changes. Conversely, a button click handler (`increment`) calls `agent.setState` to update the agent's state, which then triggers the `onStateUpdate` callback, ensuring bidirectional synchronization.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_10

LANGUAGE: tsx
CODE:
```
import { useState } from "react";
import { useAgent } from "agents/react";

function StateInterface() {
  const [state, setState] = useState({ counter: 0 });

  const agent = useAgent({
    agent: "thinking-agent",
    onStateUpdate: (newState) => setState(newState),
  });

  const increment = () => {
    agent.setState({ counter: state.counter + 1 });
  };

  return (
    <div>
      <div>Count: {state.counter}</div>
      <button onClick={increment}>Increment</button>
    </div>
  );
}
```

----------------------------------------

TITLE: Implementing Features using AI Orchestrator and Workers in TypeScript
DESCRIPTION: This asynchronous TypeScript function, `implementFeature`, orchestrates AI models to implement software features. It first calls `generateObject` with OpenAI's 'o1' model to create an implementation plan (files, change types, complexity) based on the input `featureRequest` string, validated using a Zod schema. Subsequently, it iterates through the plan, using `generateObject` again with OpenAI's 'gpt-4o' model and specialized system prompts for each file change type (create, modify, delete) to generate the actual code and explanation, also validated by Zod. It depends on `@ai-sdk/openai`, `ai`, and `zod`. The function returns an object containing the generated `plan` and the detailed `changes`.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/04 orchestrator.txt#_snippet_0

LANGUAGE: TypeScript
CODE:
```
import { openai } from '@ai-sdk/openai';
import { generateObject } from 'ai';
import { z } from 'zod';

async function implementFeature(featureRequest: string) {
  // Orchestrator: Plan the implementation
  const { object: implementationPlan } = await generateObject({
    model: openai('o1'),
    schema: z.object({
      files: z.array(
        z.object({
          purpose: z.string(),
          filePath: z.string(),
          changeType: z.enum(['create', 'modify', 'delete']),
        }),
      ),
      estimatedComplexity: z.enum(['low', 'medium', 'high']),
    }),
    system:
      'You are a senior software architect planning feature implementations.',
    prompt: `Analyze this feature request and create an implementation plan:
    ${featureRequest}`,
  });

  // Workers: Execute the planned changes
  const fileChanges = await Promise.all(
    implementationPlan.files.map(async file => {
      // Each worker is specialized for the type of change
      const workerSystemPrompt = {
        create:
          'You are an expert at implementing new files following best practices and project patterns.',
        modify:
          'You are an expert at modifying existing code while maintaining consistency and avoiding regressions.',
        delete:
          'You are an expert at safely removing code while ensuring no breaking changes.',
      }[file.changeType];

      const { object: change } = await generateObject({
        model: openai('gpt-4o'),
        schema: z.object({
          explanation: z.string(),
          code: z.string(),
        }),
        system: workerSystemPrompt,
        prompt: `Implement the changes for ${file.filePath} to support:
        ${file.purpose}

        Consider the overall feature context:
        ${featureRequest}`,
      });

      return {
        file,
        implementation: change,
      };
    }),
  );

  return {
    plan: implementationPlan,
    changes: fileChanges,
  };
}
```

----------------------------------------

TITLE: Scheduling Tasks within an Agent using TypeScript
DESCRIPTION: Shows how a `TimeAwareAgent` (extending `Agent`) uses the `this.schedule` method to schedule future actions. Tasks can be scheduled after a delay (in milliseconds), using a cron string for recurring tasks, or at a specific `Date`. Each scheduled task calls a corresponding method (`quickInsight`, `dailySynthesis`, `yearlyAnalysis`) within the agent, potentially passing data provided during scheduling.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_11

LANGUAGE: typescript
CODE:
```
export class TimeAwareAgent extends Agent {
  async initialize() {
    // Quick reflection
    this.schedule(10, "quickInsight", { focus: "patterns" });

    // Daily synthesis
    this.schedule("0 0 * * *", "dailySynthesis", {
      depth: "comprehensive",
    });

    // Milestone review
    this.schedule(new Date("2024-12-31"), "yearlyAnalysis");
  }

  async quickInsight(data) {
    await this.analyze(data.focus);
  }

  async dailySynthesis(data) {
    await this.synthesize(data.depth);
  }

  async yearlyAnalysis() {
    await this.analyze();
  }
}
```

----------------------------------------

TITLE: Connecting to an Agent Directly using AgentClient in TypeScript
DESCRIPTION: Demonstrates client-side code for connecting directly to an agent using the `AgentClient` class from `agents/client`. It initializes a connection to a specific agent instance identified by its class name (`agent`) and unique name (`name`). Event listeners are added to handle incoming messages, and the `connection.send` method is used to send JSON data to the agent.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_7

LANGUAGE: typescript
CODE:
```
import { AgentClient } from "agents/client";

const connection = new AgentClient({
  agent: "dialogue-agent",
  name: "insight-seeker",
});

connection.addEventListener("message", (event) => {
  console.log("Received:", event.data);
});

connection.send(
  JSON.stringify({
    type: "inquiry",
    content: "What patterns do you see?",
  })
);
```

----------------------------------------

TITLE: Asynchronous Literary Translation with Feedback Optimization Using OpenAI GPT Models (JavaScript)
DESCRIPTION: This function performs a threaded translation of text into a target language, utilizing GPT-4 models for initial translation, evaluation, and iterative improvement based on feedback. It depends on '@ai-sdk/openai' for model access, 'ai' library functions for text and object generation, and 'zod' for schema validation. The process aims to ensure high translation quality through multiple evaluation and refinement cycles, with input parameters including the source text and target language, and outputs the final translation and iteration count.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/05 evaluator.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
async function translateWithFeedback(text: string, targetLanguage: string) {
  let currentTranslation = '';
  let iterations = 0;
  const MAX_ITERATIONS = 3;

  // Initial translation
  const { text: translation } = await generateText({
    model: openai('gpt-4o-mini'), // use small model for first attempt
    system: 'You are an expert literary translator.',
    prompt: `Translate this text to ${targetLanguage}, preserving tone and cultural nuances:
    ${text}`,
  });

  currentTranslation = translation;

  // Evaluation-optimization loop
  while (iterations < MAX_ITERATIONS) {
    // Evaluate current translation
    const { object: evaluation } = await generateObject({
      model: openai('gpt-4o'), // use a larger model to evaluate
      schema: z.object({
        qualityScore: z.number().min(1).max(10),
        preservesTone: z.boolean(),
        preservesNuance: z.boolean(),
        culturallyAccurate: z.boolean(),
        specificIssues: z.array(z.string()),
        improvementSuggestions: z.array(z.string()),
      }),
      system: 'You are an expert in evaluating literary translations.',
      prompt: `Evaluate this translation:

      Original: ${text}
      Translation: ${currentTranslation}

      Consider:
      1. Overall quality
      2. Preservation of tone
      3. Preservation of nuance
      4. Cultural accuracy`,
    });

    // Check if quality meets threshold
    if (
      evaluation.qualityScore >= 8 &&
      evaluation.preservesTone &&
      evaluation.preservesNuance &&
      evaluation.culturallyAccurate
    ) {
      break;
    }

    // Generate improved translation based on feedback
    const { text: improvedTranslation } = await generateText({
      model: openai('gpt-4o'), // use a larger model
      system: 'You are an expert literary translator.',
      prompt: `Improve this translation based on the following feedback:
      ${evaluation.specificIssues.join('\n')}
      ${evaluation.improvementSuggestions.join('\n')}

      Original: ${text}
      Current Translation: ${currentTranslation}`,
    });

    currentTranslation = improvedTranslation;
    iterations++;
  }

  return {
    finalTranslation: currentTranslation,
    iterationsRequired: iterations,
  };
}
```

----------------------------------------

TITLE: Generating Marketing Copy with Quality Checks using OpenAI in TypeScript
DESCRIPTION: This asynchronous function `generateMarketingCopy` takes a string input and uses the OpenAI GPT-4o model to generate marketing copy. It first generates an initial version using `generateText`. Then, it evaluates the generated copy for quality metrics (presence of a call to action, emotional appeal, clarity) using `generateObject` and a Zod schema. If the quality metrics are below certain thresholds, it regenerates the copy with specific instructions for improvement before returning the final copy and its quality metrics. Dependencies include `@ai-sdk/openai`, `ai`, and `zod`.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/01 sequential.txt#_snippet_0

LANGUAGE: typescript
CODE:
```
import { openai } from "@ai-sdk/openai";
import { generateText, generateObject } from "ai";
import { z } from "zod";

export default async function generateMarketingCopy(input: string) {
  const model = openai("gpt-4o");

  // First step: Generate marketing copy
  const { text: copy } = await generateText({
    model,
    prompt: `Write persuasive marketing copy for: ${input}. Focus on benefits and emotional appeal.`,
  });

  // Perform quality check on copy
  const { object: qualityMetrics } = await generateObject({
    model,
    schema: z.object({
      hasCallToAction: z.boolean(),
      emotionalAppeal: z.number().min(1).max(10),
      clarity: z.number().min(1).max(10),
    }),
    prompt: `Evaluate this marketing copy for:
    1. Presence of call to action (true/false)
    2. Emotional appeal (1-10)
    3. Clarity (1-10)

    Copy to evaluate: ${copy}`,
  });

  // If quality check fails, regenerate with more specific instructions
  if (
    !qualityMetrics.hasCallToAction ||
    qualityMetrics.emotionalAppeal < 7 ||
    qualityMetrics.clarity < 7
  ) {
    const { text: improvedCopy } = await generateText({
      model,
      prompt: `Rewrite this marketing copy with:
      ${!qualityMetrics.hasCallToAction ? "- A clear call to action" : ""}
      ${qualityMetrics.emotionalAppeal < 7 ? "- Stronger emotional appeal" : ""}
      ${qualityMetrics.clarity < 7 ? "- Improved clarity and directness" : ""}

      Original copy: ${copy}`,
    });
    return { copy: improvedCopy, qualityMetrics };
  }

  return { copy, qualityMetrics };
}
```

----------------------------------------

TITLE: Parallel Multi-Domain Code Review with OpenAI SDK in JavaScript
DESCRIPTION: This snippet defines an async function that performs three concurrent code reviews focusing on security, performance, and maintainability using different schemas and prompts. It then synthesizes these reviews into a concise summary with a final call to generateText. Dependencies include '@ai-sdk/openai', 'ai', and 'zod' libraries. Key parameters include code input, review model configuration, and schemas for expected review output.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/03 parallel.txt#_snippet_0

LANGUAGE: JavaScript
CODE:
```
import { openai } from '@ai-sdk/openai';
import { generateText, generateObject } from 'ai';
import { z } from 'zod';

// Example: Parallel code review with multiple specialized reviewers
async function parallelCodeReview(code: string) {
  const model = openai('gpt-4o');

  // Run parallel reviews
  const [securityReview, performanceReview, maintainabilityReview] =
    await Promise.all([
      generateObject({
        model,
        system:
          'You are an expert in code security. Focus on identifying security vulnerabilities, injection risks, and authentication issues.',
        schema: z.object({
          vulnerabilities: z.array(z.string()),
          riskLevel: z.enum(['low', 'medium', 'high']),
          suggestions: z.array(z.string()),
        }),
        prompt: `Review this code:
      ${code}`,
      }),

      generateObject({
        model,
        system:
          'You are an expert in code performance. Focus on identifying performance bottlenecks, memory leaks, and optimization opportunities.',
        schema: z.object({
          issues: z.array(z.string()),
          impact: z.enum(['low', 'medium', 'high']),
          optimizations: z.array(z.string()),
        }),
        prompt: `Review this code:
      ${code}`,
      }),

      generateObject({
        model,
        system:
          'You are an expert in code quality. Focus on code structure, readability, and adherence to best practices.',
        schema: z.object({
          concerns: z.array(z.string()),
          qualityScore: z.number().min(1).max(10),
          recommendations: z.array(z.string()),
        }),
        prompt: `Review this code:
      ${code}`,
      }),
    ]);

  const reviews = [
    { ...securityReview.object, type: 'security' },
    { ...performanceReview.object, type: 'performance' },
    { ...maintainabilityReview.object, type: 'maintainability' },
  ];

  // Aggregate results using another model instance
  const { text: summary } = await generateText({
    model,
    system: 'You are a technical lead summarizing multiple code reviews.',
    prompt: `Synthesize these code review results into a concise summary with key actions:
    ${JSON.stringify(reviews, null, 2)}`,
  });

  return { reviews, summary };
}
```

----------------------------------------

TITLE: Integrating an Agent with React using the `useAgent` Hook
DESCRIPTION: Illustrates how to use the `useAgent` hook from `agents/react` within a React functional component (`AgentInterface`). The hook establishes and manages a connection to a specified agent (`dialogue-agent`, `insight-seeker`). Callbacks (`onMessage`, `onOpen`, `onClose`) handle connection events and incoming data. The returned `connection` object provides a `send` method to communicate back to the agent, triggered here by a button click.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_8

LANGUAGE: tsx
CODE:
```
import { useAgent } from "agents/react";

function AgentInterface() {
  const connection = useAgent({
    agent: "dialogue-agent",
    name: "insight-seeker",
    onMessage: (message) => {
      console.log("Understanding received:", message.data);
    },
    onOpen: () => console.log("Connection established"),
    onClose: () => console.log("Connection closed"),
  });

  const inquire = () => {
    connection.send(
      JSON.stringify({
        type: "inquiry",
        content: "What insights have you gathered?",
      })
    );
  };

  return (
    <div className="agent-interface">
      <button onClick={inquire}>Seek Understanding</button>
    </div>
  );
}
```

----------------------------------------

TITLE: Managing Agent Lifecycle: Creation and Connection in TypeScript
DESCRIPTION: Illustrates how to manage agent instances using the environment bindings configured in `wrangler.toml`. It shows creating a new unique agent instance using `env.AIAgent.newUniqueId()` and `get()`, and then calling an agent method (`processTask`). It also suggests retrieving an existing agent, potentially using a custom helper function like `getAgentByName`.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_4

LANGUAGE: typescript
CODE:
```
// Create a new instance
const id = env.AIAgent.newUniqueId();
const agent = env.AIAgent.get(id);

// Initialize with purpose
await agent.processTask({
  type: "analysis",
  context: "incoming_data",
  parameters: initialConfig,
});

// Or reconnect with an existing one
const existingAgent = await getAgentByName(env.AIAgent, "data-analyzer");
```

----------------------------------------

TITLE: Generating AI Response based on Classification using generateText - TypeScript
DESCRIPTION: Generates the final text response using the `generateText` function. The specific AI model ('gpt-4o-mini' or 'o1-mini') is selected based on the classified query complexity, and a relevant system prompt is chosen from a map based on the query type. The original customer query is used as the user prompt for generating the response.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/02 routing.txt#_snippet_3

LANGUAGE: TypeScript
CODE:
```
  // Route based on classification
  // Set model and system prompt based on query type and complexity
  const { text: response } = await generateText({
    model:
      classification.complexity === 'simple'
        ? openai('gpt-4o-mini')
        : openai('o1-mini'),
    system: {
      general:
        'You are an expert customer service agent handling general inquiries.',
      refund:
        'You are a customer service agent specializing in refund requests. Follow company policy and collect necessary information.',
      technical:
        'You are a technical support specialist with deep product knowledge. Focus on clear step-by-step troubleshooting.',
    }[classification.type],
    prompt: query,
  });
```

----------------------------------------

TITLE: WebSocket Connection and Message Handling in Frontend with PartySocket
DESCRIPTION: This code establishes a WebSocket connection from the frontend to a Durable Object instance using PartySocket SDK, enabling real-time communication for agent state updates. It listens for messages of type 'state' and updates the workflow state accordingly. Additionally, it can send initial run commands to start the agent workflow.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/README.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
const socket = usePartySocket({
  party: type,
  room: "default-room",
  onMessage: (e) => {
    const data = JSON.parse(e.data);
    switch (data.type) {
      case "state":
        setWorkflowState(data.state);
        break;
    }
  },
});
```

----------------------------------------

TITLE: Building React Client for Human-in-the-Loop Chat Interface
DESCRIPTION: Implements a React component that renders chat messages and tool approval requests. This component allows users to approve or reject tool invocations from the AI agent using buttons.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/human-in-the-loop/README.md#_snippet_1

LANGUAGE: tsx
CODE:
```
function Chat() {
  // Initialize agent and chat hooks
  const agent = useAgent({ agent: "human-in-the-loop" });
  const { messages, addToolResult } = useAgentChat({ agent });

  return (
    <div className="chat-container">
      {messages.map((message) => (
        <div key={message.id}>
          {/* Render normal messages */}
          {message.type === "text" && (
            <div className="message">{message.content}</div>
          )}

          {/* Render tool approval requests */}
          {message.type === "tool-invocation" && (
            <div className="tool-approval">
              <p>
                Approve {message.tool} for {message.args.city}?
              </p>
              <button onClick={() => addToolResult(message.id, "approve")}>
                Yes
              </button>
              <button onClick={() => addToolResult(message.id, "reject")}>
                No
              </button>
            </div>
          )}
        </div>
      ))}
    </div>
  );
}
```

----------------------------------------

TITLE: Classifying Customer Query with AI SDK generateObject - TypeScript
DESCRIPTION: Initializes the 'gpt-4o' OpenAI model and uses the `generateObject` function from the AI SDK to classify the input customer query. It uses a Zod schema to enforce the structure of the AI's output, expecting fields for reasoning, query type (general, refund, technical), and complexity (simple, complex).
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/src/flows/02 routing.txt#_snippet_2

LANGUAGE: TypeScript
CODE:
```
  const model = openai('gpt-4o');

  // First step: Classify the query type
  const { object: classification } = await generateObject({
    model,
    schema: z.object({
      reasoning: z.string(),
      type: z.enum(['general', 'refund', 'technical']),
      complexity: z.enum(['simple', 'complex']),
    }),
    prompt: `Classify this customer query:
    ${query}

    Determine:
    1. Query type (general, refund, or technical)
    2. Complexity (simple or complex)
    3. Brief reasoning for classification`,
  });
```

----------------------------------------

TITLE: Configuring Durable Objects for Agents in wrangler.toml
DESCRIPTION: Provides a JSONC configuration snippet for `wrangler.toml` (or `.cloudflare/wrangler.toml`). It defines Durable Object bindings under the `durable_objects` key, mapping a name (e.g., `AIAgent`) to its corresponding class implementation. It also includes a mandatory `migrations` section with `new_sqlite_classes` to enable persistent state storage for the specified agent class.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/agents/README.md#_snippet_3

LANGUAGE: jsonc
CODE:
```
{
  "durable_objects": {
    "bindings": [
      {
        "name": "AIAgent",
        "class_name": "AIAgent",
      },
    ],
  },
  "migrations": [
    {
      "tag": "v1",
      // Mandatory for the Agent to store state
      "new_sqlite_classes": ["AIAgent"],
    },
  ],
}
```

----------------------------------------

TITLE: Configuring Durable Objects in wrangler.toml
DESCRIPTION: This TOML configuration file demonstrates how to set up Durable Objects for the agents within a Cloudflare Workers project. It defines the bindings for each agent class to Durable Objects, enabling state management. It also sets up database migrations using SQLite.
SOURCE: https://github.com/cloudflare/agents/blob/main/packages/hono-agents/README.md#_snippet_2

LANGUAGE: toml
CODE:
```
[durable_objects]
bindings = [
  { name = "ChatAgent", class_name = "ChatAgent" },
  { name = "AssistantAgent", class_name = "AssistantAgent" }
]

[[migrations]]
tag = "v1"
new_sqlite_classes = ["ChatAgent", "AssistantAgent"]
```

----------------------------------------

TITLE: Durable Object State Management for AI Agents
DESCRIPTION: This snippet defines the internal state structure for a Durable Object managing an AI agent, including flags indicating whether the agent is running and its output data. It is used within the Durable Object class to maintain persistent state across executions, supporting real-time updates and persistence.
SOURCE: https://github.com/cloudflare/agents/blob/main/guides/anthropic-patterns/README.md#_snippet_1

LANGUAGE: TypeScript
CODE:
```
state: {
  isRunning: boolean;
  output: any;
} = {
  isRunning: false,
  output: undefined,
};
```

----------------------------------------

TITLE: Defining Resources and Tools in McpAgent using MCP SDK
DESCRIPTION: This snippet demonstrates the implementation of the McpAgent class, showcasing how to initialize an MCP server with specific name and version, then define a resource and a tool within the async init() method. It utilizes the MCP SDK functions `resource` and `tool` to register these entities, facilitating resource management and computation features.
SOURCE: https://github.com/cloudflare/agents/blob/main/examples/mcp/README.md#_snippet_0

LANGUAGE: TypeScript
CODE:
```
export class MyMCP extends McpAgent<Env> {
  server = new McpServer({
    name: "Demo",
    version: "1.0.0",
  });

  async init() {
    this.server.resource(`counter`, `mcp://resource/counter`, (uri) => {
      // ...
    });

    this.server.tool(
      "add",
      "Add two numbers together",
      { a: z.number(), b: z.number() },
      async ({ a, b }) => {
        // ...
      }
    );
  }
}
```

### State synchronization API

:::note

To learn more about how to manage state within an Agent, refer to the documentation on [managing and syncing state](/agents/api-reference/store-and-sync-state/).

:::

#### State

Methods and types for managing Agent state.

```ts
// State management in the Agent class
class Agent<Env, State = unknown> {
  // Initial state that will be set if no state exists yet
  initialState: State = {} as unknown as State;

  // Current state of the Agent, persisted across restarts
  get state(): State;

  // Update the Agent's state
  // Persists to storage and notifies all connected clients
  setState(state: State): void;

  // Called when state is updated from any source
  // Override to react to state changes
  onStateUpdate(state: State, source: "server" | Connection): void;
}
```

<TypeScriptExample>

```ts
// Example of state management in an Agent
interface ChatState {
  messages: Array<{ sender: string; text: string; timestamp: number }>;
  participants: string[];
  settings: {
    allowAnonymous: boolean;
    maxHistoryLength: number;
  };
}

interface Env {
	// Your bindings and environment variables
}

// Inside your Agent class
export class YourAgent extends Agent<Env, ChatState> {
  async addMessage(sender: string, text: string) {
    // Update state with new message
    this.setState({
      ...this.state,
      messages: [
        ...this.state.messages,
        { sender, text, timestamp: Date.now() }
      ].slice(-this.state.settings.maxHistoryLength) // Maintain max history
    });

    // The onStateUpdate method will automatically be called
    // and all connected clients will receive the update
  }

  // Override onStateUpdate to add custom behavior when state changes
  onStateUpdate(state: ChatState, source: "server" | Connection) {
    console.log(`State updated by ${source === "server" ? "server" : "client"}`);

    // You could trigger additional actions based on state changes
    if (state.messages.length > 0) {
      const lastMessage = state.messages[state.messages.length - 1];
      if (lastMessage.text.includes('@everyone')) {
        this.notifyAllParticipants(lastMessage);
      }
    }
  }
}
```
</TypeScriptExample>

# Vercel AI SDK

URL: https://developers.cloudflare.com/workers-ai/configuration/ai-sdk/

Workers AI can be used with the [Vercel AI SDK](https://sdk.vercel.ai/) for JavaScript and TypeScript codebases.

## Setup

Install the [`workers-ai-provider` provider](https://sdk.vercel.ai/providers/community-providers/cloudflare-workers-ai):

```bash
npm install workers-ai-provider
```

Then, add an AI binding in your Workers project Wrangler file:

```toml
[ai]
binding = "AI"
```

## Models

The AI SDK can be configured to work with [any AI model](/workers-ai/models/).

```js
import { createWorkersAI } from 'workers-ai-provider';

const workersai = createWorkersAI({ binding: env.AI });

// Choose any model: https://developers.cloudflare.com/workers-ai/models/
const model = workersai('@cf/meta/llama-3.1-8b-instruct', {});
```

## Generate Text

Once you have selected your model, you can generate text from a given prompt.

```js
import { createWorkersAI } from 'workers-ai-provider';
import { generateText } from 'ai';

type Env = {
  AI: Ai;
};

export default {
  async fetch(_: Request, env: Env) {
    const workersai = createWorkersAI({ binding: env.AI });
    const result = await generateText({
      model: workersai('@cf/meta/llama-2-7b-chat-int8'),
      prompt: 'Write a 50-word essay about hello world.',
    });

    return new Response(result.text);
  },
};
```

## Stream Text

For longer responses, consider streaming responses to provide as the generation completes.

```js
import { createWorkersAI } from 'workers-ai-provider';
import { streamText } from 'ai';

type Env = {
  AI: Ai;
};

export default {
  async fetch(_: Request, env: Env) {
    const workersai = createWorkersAI({ binding: env.AI });
    const result = streamText({
      model: workersai('@cf/meta/llama-2-7b-chat-int8'),
      prompt: 'Write a 50-word essay about hello world.',
    });

    return result.toTextStreamResponse({
      headers: {
        // add these headers to ensure that the
        // response is chunked and streamed
        'Content-Type': 'text/x-unknown',
        'content-encoding': 'identity',
        'transfer-encoding': 'chunked',
      },
    });
  },
};
```

## Generate Structured Objects

You can provide a Zod schema to generate a structured JSON response.

```js
import { createWorkersAI } from 'workers-ai-provider';
import { generateObject } from 'ai';
import { z } from 'zod';

type Env = {
  AI: Ai;
};

export default {
  async fetch(_: Request, env: Env) {
    const workersai = createWorkersAI({ binding: env.AI });
    const result = await generateObject({
      model: workersai('@cf/meta/llama-3.1-8b-instruct'),
      prompt: 'Generate a Lasagna recipe',
      schema: z.object({
        recipe: z.object({
          ingredients: z.array(z.string()),
          description: z.string(),
        }),
      }),
    });

    return Response.json(result.object);
  },
};
```

---

# Workers Bindings

URL: https://developers.cloudflare.com/workers-ai/configuration/bindings/

import { Type, MetaInfo, WranglerConfig } from "~/components";

## Workers

[Workers](/workers/) provides a serverless execution environment that allows you to create new applications or augment existing ones.

To use Workers AI with Workers, you must create a Workers AI [binding](/workers/runtime-apis/bindings/). Bindings allow your Workers to interact with resources, like Workers AI, on the Cloudflare Developer Platform. You create bindings on the Cloudflare dashboard or by updating your [Wrangler file](/workers/wrangler/configuration/).

To bind Workers AI to your Worker, add the following to the end of your Wrangler file:

<WranglerConfig>

```toml
[ai]
binding = "AI" # i.e. available in your Worker on env.AI
```

</WranglerConfig>

## Pages Functions

[Pages Functions](/pages/functions/) allow you to build full-stack applications with Cloudflare Pages by executing code on the Cloudflare network. Functions are Workers under the hood.

To configure a Workers AI binding in your Pages Function, you must use the Cloudflare dashboard. Refer to [Workers AI bindings](/pages/functions/bindings/#workers-ai) for instructions.

## Methods

### async env.AI.run()

`async env.AI.run()` runs a model. Takes a model as the first parameter, and an object as the second parameter.

```javascript
const answer = await env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
    prompt: "What is the origin of the phrase 'Hello, World'"
});
```

**Parameters**

* `model` <Type text="string" /> <MetaInfo text="required" />

  * The model to run.

  **Supported options**

  * `stream` <Type text="boolean" /> <MetaInfo text="optional" />
    * Returns a stream of results as they are available.

```javascript
const answer = await env.AI.run('@cf/meta/llama-3.1-8b-instruct', {
    prompt: "What is the origin of the phrase 'Hello, World'",
    stream: true
});

return new Response(answer, {
    headers: { "content-type": "text/event-stream" }
});
```

---